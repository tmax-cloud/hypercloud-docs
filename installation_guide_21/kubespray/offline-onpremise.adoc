= 온프레미스 환경에서 구축

본 장에서는 온프레미스 환경에서 폐쇄망으로 Kubespray를 이용하여 HyperCloud를 설치하는 방법에 대해서 설명한다.

설치하는 과정은 크게 다음과 같다.

. <<K8sInfraOn, 쿠버네티스 인프라 구성>>
. <<ArgoCDInstallOn, ArgoCD 설치>>
. <<MasterClusterOn, 마스터 클러스터 설치>>
. <<SingleClusterOn, 싱글 클러스터 설치>>
. <<ResourceDeployOn, 리소스 배포>>

[#K8sInfraOn]
== 쿠버네티스 인프라 구성
본 절에서는 Kubespray를 이용하여 쿠버네티스 인프라를 구성하는 방법에 대해서 설명한다.

쿠버네티스 인프라를 구성하는 순서는 다음과 같다.

. <<KubesprayDecompressionK8sOn, Kubespray 파일 압축 해제>>
. <<KubesprayConfigK8sOn, Kubespray 환경 설정>>
. <<KubesprayRunK8sOn, Kubespray 실행>>

[#KubesprayDecompressionK8sOn]
=== Kubespray 파일 압축 해제

쿠버네티스 설치를 위해 테크넷을 통해서 다운로드한 *kubespray-infra.zip* 파일의 압축을 해제한다.

[#KubesprayConfigK8sOn]
=== Kubespray 환경 설정

Kubespray를 실행하기 위한 필수 설정 파일들을 정의한다.

NOTE: Kubespray를 실행하기 위해서는 사전 준비가 필요하다. 반드시  xref:offline-intro.adoc[설치 전 준비사항]을 참고하여 환경을 구성한다.

CAUTION: RHEL 운영체제일 경우 `kubespray-infra/cluster.yml` 파일을 열어 *- { role: bootstrap-os, tags: bootstrap-os}* 행을 반드시 주석 처리해야 한다.

. *노드 정보 등록*
+ 
`kubespray-infra/inventory/tmaxcloud/inventory.ini` 파일을 열어 kubespray에서 설치할 노드들의 정보를 등록한다. +
이때 all 그룹은 `*[호스트 이름] [Ansible IP 주소] [Backup IP 주소]*` 형태로 작성하고, 그 외 그룹은 all 그룹에서 정의한 호스트 이름만 작성한다.

. *쿠버네티스 기본 정보 설정*
+
`kubespray-infra/inventory/tmaxcloud/group_vars/all/all.yml` 파일을 열어 Kubernetes의 기본 정보를 설정한다.
+
.예시
----
apiserver_loadbalancer_domain_name: "10.0.10.50" <1> 
loadbalancer_apiserver:
  address: 10.0.10.50 <2>
  port: 6443 <3>
  
upstream_dns_servers: <4>
  - 192.168.1.150  
----
+
<1> 쿠버네티스 API 서버 주소

* 싱글 마스터의 경우: 마스터 노드의 IP 주소
* 멀티 마스터의 경우: API 서버와 통신할 수 있는 VIP 주소 
<2> 쿠버네티스 API 서버와 통신할 수 있는 VIP 주소
<3> 쿠버네티스 API 서버 포트 번호
<4> 도메인 네임서버 주소
 
. *Calico 구성 정보 설정*
+
`kubespray-infra/inventory/tmaxcloud/group_vars/k8s_cluster/k8s-net-calico.yml` 파일을 열어 Calico 관련 정보를 설정한다.
+
.예시
----
calico_ip_auto_method: "cidr=192.168.7.0/24" <1>
----
+
<1> Calico가 자동으로 감지할 노드들의 CIDR 값 

. *추가 설치 모듈 설정*
+
`kubespray-infra/inventory/tmaxcloud/group_vars/k8s_cluster/addons.yml` 파일을 열어 추가 설치가 가능한 모듈 관련 정보를 설정한다.
+
.예시
----
default_storageclass_name: nfs <1>
sc_name_0: nfs <2>
sc_name_999: nfs <3>
nfs_namespace: nfs <4>
nfs_server: 192.168.7.17 <5>
nfs_path: /root/test <6>
----
+
<1> 기본값으로 설정할 스토리지 이름
<2> HyperRegistry에서 Postgres PVC의 스토리지 클래스 이름
<3> 그 외의 PVC 스토리지 클래스 이름
<4> NFS 스토리지 네임스페이스 이름
<5> NFS 서버 주소  
<6> NFS 서버 공유 폴더 경로

. *폐쇄망 정보 설정*
+
`kubespray-infra/inventory/tmaxcloud/group_vars/all/offline.yml` 파일을 열어 폐쇄망 관련 정보를 설정한다.
+
.예시
----
is_this_offline: true <1>
registry_host: "10.0.10.50:5000" <2>
files_repo: "http://172.22.5.2" <3>
----
+
<1> 폐쇄망 환경 여부 (폐쇄망일 경우 true)
<2> 프라이빗 레지스트리 주소
<3> 파일 리포지터리 주소

. *IP 주소 대역 설정*
+
`kubespray-infra/inventory/tmaxcloud/group_vars/k8s_cluster/k8s-cluster.yml` 파일을 열어 파드 및 서비스의 IP 주소 대역 정보를 설정한다.
+
.예시
----
# Kubernetes internal network for services, unused block of space.
kube_service_addresses: 10.96.0.0/24 <1>

# internal network. When used, it will assign IP
# addresses from this range to individual pods.
# This network must be unused in your network infrastructure!
kube_pods_subnet: 10.244.0.0/24 <2>
----
+
<1> 서비스 IP 주소 대역
<2> 파드 서브넷 IP 주소 대역

[#KubesprayRunK8sOn]
=== Kubespray 실행

ansible-playbook 명령을 사용하여 Kubespray를 실행한다.
----
$ ansible-playbook -i inventory/tmaxcloud/inventory.ini --become --become-user=root cluster.yml
----

[#ArgoCDInstallOn]
== ArgoCD 설치
본 절에서는 Kubespray를 이용하여 ArgoCD를 설치하는 방법에 대해서 설명한다.

ArgoCD를 설치하는 순서는 다음과 같다.

. <<KubesprayDecompressionArgoOn, Kubespray 파일 압축 해제>>
. <<KubesprayConfigArgoOn, Kubespray 환경 설정>>
. <<KubesprayRunArgoOn, Kubespray 실행>>

[#KubesprayDecompressionArgoOn]
=== Kubespray 파일 압축 해제

ArgoCD 설치를 위해 테크넷을 통해서 다운로드한 *kubespray-onpremise.zip* 파일의 압축을 해제한다.

[#KubesprayConfigArgoOn]
=== Kubespray 환경 설정

Kubespray를 실행하기 위한 필수 설정 파일들을 정의한다.

CAUTION: RHEL 운영체제일 경우 `kubespray-onpremise/cluster.yml` 파일을 열어 *- { role: bootstrap-os, tags: bootstrap-os}* 행을 반드시 주석 처리해야 한다.

. *노드 정보 등록*
+ 
`kubespray-onpremise/inventory/tmaxcloud/inventory.ini` 파일을 열어 kubespray에서 설치할 노드들의 정보를 등록한다. + 
이때 all 그룹은 `*[호스트 이름] [Ansible IP 주소] [Backup IP 주소]*` 형태로 작성하고, 그 외 그룹은 all 그룹에서 정의한 호스트 이름만 작성한다.

. *폐쇄망 정보 설정*
+
`kubespray-onpremise/inventory/tmaxcloud/group_vars/all/offline.yml` 파일을 열어 폐쇄망 관련 정보를 설정한다.
+
.예시
----
is_this_offline: true <1>
registry_host: "10.0.10.50:5000" <2>
files_repo: "http://172.22.5.2" <3>
----
+
<1> 폐쇄망 환경 여부 (폐쇄망일 경우 true)
<2> 프라이빗 레지스트리 주소
<3> 파일 리포지터리 주소

. *사용자 지정 도메인 등록*
+
`kubespray-onpremise/inventory/tmaxcloud/group_vars/k8s_cluster/k8s-cluster.yml` 파일을 열어 외부에 노출할 사용자 지정 도메인의 정보를 등록한다.
+
.예시
----
# Enable extra custom DNS domain - by sophal_hong@tmax.co.kr
enable_local_nip_domain: false <1>
enable_custom_domain: true <2>
custom_domain_name: "cloudqa.com" <3>
custom_domain_ip: 172.22.7.2 <4>
api_server_dns_cfwhn: true <5>

# Kubernetes internal network for services, unused block of space.
kube_service_addresses: 10.96.0.0/24 <6>

# internal network. When used, it will assign IP
# addresses from this range to individual pods.
# This network must be unused in your network infrastructure!
kube_pods_subnet: 10.244.0.0/24 <7>
----
+
<1> nip.io 도메인의 사용 여부 (Self-Signed 도메인을 사용할 경우 true)
<2> 커스텀 도메인의 사용 여부 (DNS를 사용할 경우 true)
<3> 프록시 노드에 맵핑된 DNS 이름
<4> 프록시 노드의 IP 주소 
<5> kube-apiserver의 DNS 정책으로 "ClusterFirstWithHostNet" 적용 여부 
<6> 서비스 IP 주소 대역
<7> 파드 서브넷 IP 주소 대역

. *설치할 애플리케이션 구성 정보 확인*
+
Kubespray로 설치될 애플리케이션(`nginx`, `harbor`, `gitlab`, `argocd`)의 구성 정보를 확인 및 설정한다. (QA: harbor -> hyperregistry) +
해당 애플리케이션의 구성 정보는 기본적으로 `kubespray-onpremise/roles/bootstrap-cloud/defaults/main.yml` 파일에서 설정이 가능하며, 추가적으로 커스터마이징이 필요할 경우에는 `kubespray-onpremise/roles/bootstrap-cloud/task/` 및 `kubespray-onpremise/roles/bootstrap-cloud/templates/` 하위 파일에서 설정이 가능하다.
+
온프레미스 환경에서는 다음과 같이 인그레스의 서비스 타입을 "NodePort"로 설정해야 한다.(QA: 설명이 모호해서 삭제) +
(QA: hyperregistry는 default storageclass가 nfs로 고정되어 있어서 default storageclass가 바뀌다면 설정에 맞게 수정해야 한다.)
+
.kubespray-onpremise/roles/bootstrap-cloud/defaults/main.yml
----
ingress_nginx_service_type: NodePort (QA: 삭제)
(QA: hyperregistry_storage_class: "nfs"   추가)
----

[#KubesprayRunArgoOn]
=== Kubespray 실행

ansible-playbook 명령을 사용하여 애플리케이션을 설치한다.
----
$ ansible-playbook -i inventory/tmaxcloud/inventory.ini --become --become-user=root cluster.yml -t bootstrap-cloud
----

NOTE: 애플리케이션 설치가 정상적으로 완료되면, Gitlab과 ArgoCD 간의 저장소가 자동으로 연동된다.

[#MasterClusterOn]
== 마스터 클러스터 설치

. *master-values.yaml 파일 수정*
+
`kubespray-onpremise/roles/bootstrap-cloud/templates/argocd_installer/application/helm/master-values.yaml` 파일을 열어 애플리케이션을 Helm Chart로 설치하기 위해 사용할 환경 변수를 정의한다.
+
.예시
----
...
global:
  privateRegistry: 10.0.0.1:5000 <1>
...
  gatewayBootstrap:
    enabled: true <2>
    svc_type: NodePort <3>
    tls:
      selfsigned:
        enabled: false <4>
      acme:
        enabled: true <5>
        email: test@tmax.co.kr
        dns:
          type: route53
          accessKeyID: AKIAVXXXXXXXXXX <6>
          accessKeySecret: kFOYY4dYyXXXXXXXXXXXXXXXXXXXX <7>
          hostedZoneID: Z077XXXXXXXXXXXX <8>
        environment: production <9>
...
(QA: 변경 ↓)
global:
  privateRegistry: 10.0.0.1:5000 <1>
  domain: cloudqa.com <2>
...  
  gatewayBootstrap:
    enabled: true <3>
    svc_type: NodePort <4>
    tls:
      selfsigned:
        enabled: false <5>
      acme:
        enabled: true <6>
        email: test@tmax.co.kr
        dns:
          type: route53
          accessKeyID: AKIAVXXXXXXXXXX <7>
          accessKeySecret: kFOYY4dYyXXXXXXXXXXXXXXXXXXXX <8>
          hostedZoneID: Z077XXXXXXXXXXXX <9>
        environment: production <10>
----
+
<1> 프라이빗 컨테이너 이미지 레지스트리의 주소
<2> 애플리케이션 설치 시 인그레스 주소에 사용될 커스텀 도메인 이름 (QA: 추가)
<3> 게이트웨이 부트스트랩의 포함 여부
<4> 네트워크 서비스 타입 (QA: 추가)(NodePort, LoadBalancer) 
<5> 자체 서명 인증서의 사용 여부
<6> Route 53으로 생성한 도메인을 사용하기 위한 자동 인증서 관리 환경 사용 여부
<7> AWS에서 사용하는 계정의 액세스 키 ID
<8> 액세스 키 ID에 대한 시크릿 키
<9> Route 53으로 생성한 도메인에 대한 호스팅 영역 ID
<10> 실제 사용할 인증서 발급 용도 (QA: 추가)(운영용: production, 테스트용 : staging)
+
NOTE: 예시 외에 설치할 모듈에 대한 enabled 값을 true로 설정하거나, 필요시 사용자 지정 도메인을 등록한다.(QA: 사용자 지정 도메인 -> 서브 도메인)

. *shared-values.yaml 파일 수정*
+
`kubespray-onpremise/roles/bootstrap-cloud/templates/argocd_installer/application/helm/shared-values.yaml` 파일을 열어 마스터 클러스터에 필요한 구성 정보를 설정한다.
+
.예시
----
...
    repoURL: https://gitlab.cloudqa.com/root/argocd-installer.git <1>
...
global:
  network:
    disabled: true <2>
  domain: cloudqa.com <3>
  keycloak:
    domain: hyperauth.cloudqa.com <4>
...
(QA: 변경 ↓)
    repoURL: https://gitlab.cloudqa.com/root/argocd-installer.git <1>
    targetRevision: HEAD <2>
...
global:
  timezone: UTC <3>
  network:
    disabled: true <4>
...    
  masterSingle:
    enabled: true <5>
    hyperAuthDomain: "hyperauth.cloudqa.com" <6>
...
----
<1> ArgoCD와 연동된 Gitlab 저장소 주소 (Gitlab의 경우 url 마지막에 .git을 추가)
<2> 폐쇄망 환경 여부 (폐쇄망일 경우 true)
<3> 애플리케이션 설치 시 인그레스 주소에 사용될 커스텀 도메인 이름
<4> 설치할 HyperAuth 도메인 이름

(QA: 변경 ↓)

<1> ArgoCD와 연동된 Gitlab 저장소 주소 (Gitlab의 경우 url 마지막에 .git을 추가)
<2> Gitlab에 연동되어 있는 argocd-installer의 브랜치 이름
<3> 애플리케이션 타임존 설정 (UTC, Asia/Seoul)
<4> 폐쇄망 환경 여부 (폐쇄망일 경우 true)
<5> 마스터 클러스터와 싱글 클러스터의 hyperauth 연동 여부
<6> 마스터 클러스터와 싱글 클러스터에서 사용할 hyperauth 주소

. *애플리케이션 변수 설정*
+
`kubespray-onpremise/roles/bootstrap-cloud/templates/argocd_installer/application/app_of_apps/master-applications.yaml` 파일을 열어 마스터 클러스터의 애플리케이션 변수를 설정한다.
+
.예시
----
spec:
  ...
  source:
    ...
    repoURL: https://gitlab.cloudqa.com/root/argocd-installer.git <1> 
    targetRevision: HEAD <2>
----
<1> ArgoCD와 연동된 Gitlab 저장소 주소 (Gitlab의 경우 url 마지막에 .git을 추가)
<2> Gitlab에 연동되어 있는 argocd-installer의 브랜치 이름

. *Gitlab 동기화 작업*
+
ArgoCD와 연동된 Gitlab의 argocd-installer 브랜치에서 `master-values.yaml`, `shared-values.yaml`, `master-applications.yaml` 파일을 열어 위의 1~3번 과정과 동일하게 환경 변수를 설정한다.

. *애플리케이션 등록*
+
설치 환경에 애플리케이션을 등록한다.
+
----
$ kubectl -n argocd apply -f application/app_of_apps/master-applications.yaml
----

[#SingleClusterOn]
== 싱글 클러스터 설치

. *애플리케이션 파일 생성*
+
Console UI상에서 싱글 클러스터 상태가 "Sync Needed"로 변경되면 해당 url을 클릭한다. +
이때 ArgoCD UI로 이동되며 사용자가 Application을 Sync해주어야 한다.
+
.예시
----
(QA: Console UI 캡처화면이 있으면 이해가 쉬울것같습니다)
----

. *애플리케이션 변수 설정*
+
1번 과정에서 이동한 싱글클러스터의 애플리케이션 Repository와 Target Revision을 설정한다. 
+
.예시
----
(QA: Argocd UI 캡처화면이 있으면 이해가 쉬울것같습니다)
----

[#ResourceDeployOn]
== 리소스 배포

애플리케이션 동기화 작업을 통해 리소스를 배포한다.

이때 마스터 클러스터와 싱글 클러스터에서 각각 동기화 작업을 진행해야 하며, 각 애플리케이션의 동기화 순서는 아래를 참고한다.

[CAUTION]
.마스터 클러스터 동기화 순서
====
마스터 클러스터에서 애플리케이션 동기화 순서는 다음과 같다. 반드시 순서에 맞게 동기화 작업을 수행한다. +
1. api-gateway-bootstrap(cert-manager + jwt-decode-auth + api-gateway with console) +
2. strimzi-kafka-operator +
3. hyperauth +
4. opensearch +
5. prometheus +
6. grafana +
7. service-mesh(istio, jaeger, kiali) +
8. cluster-api(aws, vsphere) +
9. template-service-broker +
10. catalog-controller +
11. hypercloud +
12. cicd-operator(tekton) +
13. redis-operator +
14. image-validating-webhook +
*※ 온프레미스 환경의 경우 `api-gateway-bootstrap` 동기화 후 반드시 Traefik 기반의 API 게이트웨이를 구성해야 한다. 구성 방법에 대한 자세한 내용은 <<TraefikApiGatewayOn, "Traefik 기반의  API 게이트웨이 구성">>을 참고한다.*
+
(QA: 수정 ↓) +
1. api-gateway-bootstrap(namespaces + cert-manager + jwt-decode-auth + api-gateway with console) +
2. gitlab, argocd, hyperregistry +
3. strimzi-kafka-operator +
4. hyperauth +
5. opensearch or loki +
6. prometheus +
7. grafana-operator +
8. service-mesh(istio, jaeger, kiali) +
9. hypercloud +
10. template-service-broker +
11. catalog-controller +
12. cicd-operator(tekton) +
13. cluster-api(aws, vsphere) +
14. redis-operator, helm-apiserver, service-binding-operator +
15. image-validating-webhook +
*(QA: 삭제)※ 온프레미스 환경의 경우 `api-gateway-bootstrap` 동기화 후 반드시 Traefik 기반의 API 게이트웨이를 구성해야 한다. 구성 방법에 대한 자세한 내용은 <<TraefikApiGatewayOn, "Traefik 기반의  API 게이트웨이 구성">>을 참고한다.*
====

[CAUTION]
.싱글 클러스터 동기화 순서
====
싱글 클러스터에서 애플리케이션 동기화 순서는 다음과 같다. 반드시 순서에 맞게 동기화 작업을 수행한다. +
1. api-gateway-bootstrap(cert-manager + jwt-decode-auth + api-gateway without console) +
2. strimzi-kafka-operator +
3. opensearch +
4. prometheus +
5. grafana +
6. service-mesh(istio, jaeger, kiali) +
7. harbor +
8. cicd-operator(tekton) +
9. redis-operator +
*※ 온프레미스 환경의 경우 `api-gateway-bootstrap` 동기화 후 반드시 Traefik 기반의 API 게이트웨이를 구성해야 한다. 구성 방법에 대한 자세한 내용은 <<TraefikApiGatewayOn, "Traefik 기반의  API 게이트웨이 구성">>을 참고한다.*
+
(QA: 수정 ↓) +
1. api-gateway-bootstrap(namespaces + cert-manager + jwt-decode-auth + api-gateway without console) + 
2. opensearch or loki +
3. prometheus +
4. grafana-operator +
5. hyperregistry +
6. service-mesh(istio, jaeger, kiali) + 
7. template-service-broker +
8. catalog-controller, cicd-operator(tekton), redis-operator, helm-apiserver, service-binding-operator +
9. image-validating-webhook +
*(QA: 삭제)※ 온프레미스 환경의 경우 `api-gateway-bootstrap` 동기화 후 반드시 Traefik 기반의 API 게이트웨이를 구성해야 한다. 구성 방법에 대한 자세한 내용은 <<TraefikApiGatewayOn, "Traefik 기반의  API 게이트웨이 구성">>을 참고한다.*
====

. *ArgoCD 콘솔 접속*
+
웹 브라우저의 주소 표시줄에 ArgoCD 서버의 주소를 입력한다.
+
[NOTE]
====
ArgoCD 서버 주소는 다음의 명령을 실행하여 확인할 수 있다.
----
$ kubectl get svc -n argocd argocd-server 
(QA: 수정 $ kubectl get ingress -n argocd) 
----
====

. *ArgoCD 콘솔 로그인*
+
ArgoCD 콘솔 로그인 화면이 열리면 계정 아이디와 비밀번호를 입력한 후 *[SIGN IN]* 버튼을 클릭한다.
+
[NOTE]
====
ArgoCD 계정 아이디 및 초기 비밀번호 정보는 다음의 명령을 실행하여 확인할 수 있다.
----
$ kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo
----
ArgoCD 콘솔에 첫 로그인 시 위에서 확인한 계정 정보로 로그인이 가능하며, 로그인 후 *[User Info]* 메뉴를 통해 비밀번호를 변경할 수 있다.
====

. *동기화할 애플리케이션 검색*
+
동기화 작업을 수행할 애플리케이션을 검색한 후 *[SYNC]* 버튼을 클릭한다.
+
image::../images/figure_application_sync_01.png[]

. *동기화 옵션 설정*
+
동기화할 리소스 및 동기화 옵션을 설정한 후 *[SYNCHRONIZE]* 버튼을 클릭한다.
+
image::../images/figure_application_sync_02.png[]

. *상태 확인*
+
애플리케이션의 *Status* 항목에 "Healthy"와 "Synced"가 표시되는지 확인한다.
+
image::../images/figure_application_sync_03.png[]

[#TraefikApiGatewayOn]
== Traefik 기반의 API 게이트웨이 구성
(QA: 이 부분 전체 삭제 : gitlab, argocd, sync를 통해 해당 작업 자동화 했습니다.)

Gitlab과 ArgoCD에서 Traefik 게이트웨이를 사용하도록 설정한다.

=== Gitlab
. 다음의 명령을 실행하여 Gitlab에 대해 인그레스 리소스를 편집한다.
+
----
$ kubectl edit ingress -n gitlab-system gitlab-ingress
----
. 편집 모드에서 다음과 같이 정보를 추가한다.
+
----
...
metadata:
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure <1>
...
  labels:
    ingress.tmaxcloud.org/name: gitlab <2>
...
spec:
  ingressClassName: tmax-cloud <3>
...
----
<1> 주석 추가
<2> 레이블 추가
<3> 인그레스 클래스 추가

=== ArgoCD
. 다음의 명령을 실행하여 ArgoCD에 대해 인그레스 리소스를 편집한다.
+
----
$ kubectl edit ingress -n argocd argocd-server-ingress
----
. 편집 모드에서 다음과 같이 정보를 추가 및 수정한다.
+
----
...
metadata:
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure <1>
...
  labels:
    ingress.tmaxcloud.org/name: argocd <2>
...
spec:
  ingressClassName: tmax-cloud <3>
  rules:
    http:
      paths:
      - backend:
          serviceName: argocd-server
          servicePort: http <4>
...
----
<1> 주석 추가
<2> 레이블 추가
<3> 인그레스 클래스 추가
<4> 트래픽을 처리할 서비스 포트를 ``http``로 수정
